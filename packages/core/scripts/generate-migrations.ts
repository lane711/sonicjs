#!/usr/bin/env npx tsx
/**
 * Script to generate a TypeScript file containing all migration SQL
 * This is necessary because Cloudflare Workers don't have filesystem access at runtime
 *
 * Usage: npx tsx scripts/generate-migrations.ts
 */

import * as fs from 'fs'
import * as path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const migrationsDir = path.join(__dirname, '..', 'migrations')
const outputFile = path.join(__dirname, '..', 'src', 'db', 'migrations-bundle.ts')

interface MigrationInfo {
  id: string
  name: string
  filename: string
  description: string
}

// Parse migration filename to extract info
function parseMigrationFilename(filename: string): MigrationInfo | null {
  const match = filename.match(/^(\d+)_(.+)\.sql$/)
  if (!match) return null

  const id = match[1]
  const nameSlug = match[2]
  const name = nameSlug
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')

  return {
    id,
    name,
    filename,
    description: `Migration ${id}: ${name}`
  }
}

function generateMigrationsBundle() {
  // Read all migration files
  const files = fs.readdirSync(migrationsDir)
    .filter(f => f.endsWith('.sql'))
    .sort()

  const migrations: Array<MigrationInfo & { sql: string }> = []

  for (const filename of files) {
    const info = parseMigrationFilename(filename)
    if (!info) {
      console.warn(`Skipping invalid migration filename: ${filename}`)
      continue
    }

    const filePath = path.join(migrationsDir, filename)
    const sql = fs.readFileSync(filePath, 'utf-8')

    migrations.push({
      ...info,
      sql
    })
  }

  // Generate TypeScript file
  const output = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by: scripts/generate-migrations.ts
 * Generated at: ${new Date().toISOString()}
 *
 * This file contains all migration SQL bundled for use in Cloudflare Workers
 * where filesystem access is not available at runtime.
 */

export interface BundledMigration {
  id: string
  name: string
  filename: string
  description: string
  sql: string
}

export const bundledMigrations: BundledMigration[] = [
${migrations.map(m => `  {
    id: '${m.id}',
    name: '${m.name.replace(/'/g, "\\'")}',
    filename: '${m.filename}',
    description: '${m.description.replace(/'/g, "\\'")}',
    sql: ${JSON.stringify(m.sql)}
  }`).join(',\n')}
]

// Map for quick lookup by ID
export const migrationsByIdMap = new Map<string, BundledMigration>(
  bundledMigrations.map(m => [m.id, m])
)

// Get migration SQL by ID
export function getMigrationSQLById(id: string): string | null {
  return migrationsByIdMap.get(id)?.sql ?? null
}

// Get all migration info (without SQL for lighter payloads)
export function getMigrationList(): Array<Omit<BundledMigration, 'sql'>> {
  return bundledMigrations.map(({ sql, ...rest }) => rest)
}
`

  // Ensure output directory exists
  const outputDir = path.dirname(outputFile)
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true })
  }

  // Write the file
  fs.writeFileSync(outputFile, output)

  console.log(`Generated migrations bundle with ${migrations.length} migrations:`)
  migrations.forEach(m => {
    console.log(`  - ${m.id}: ${m.name} (${m.sql.length} bytes)`)
  })
  console.log(`\nOutput: ${outputFile}`)
}

generateMigrationsBundle()
